
\label{cap_referencial}

\section{Lógica proposicional}

\indent

Esta seção apresenta os conceitos básicos que definem a lógica proposicional.

\begin{definition}\textbf{(Sintaxe)}
	
	Seja o conjunto infinito e enumerável $\mathcal{P} = \{a,b,...,a_1,a_2,...,b_1,b_2,...\}$. Dizemos que $\mathcal{P}$ é o conjunto dos \emph{símbolos proposicionais}.
	
    Se $\phi \in \mathcal{P}$, dizemos que $\phi$ é uma \emph{fórmula bem-formada}, ou simplesmente que $\phi$ é uma \emph{fórmula}. Além disso, se $\phi_1,...,\phi_n$ são fórmulas quaisquer, onde $n \in \mathbb{N} \cup \{0\}$ e $\phi$ é de uma das formas a seguir, então $\phi$ também é uma fórmula:
    \begin{enumerate}
        \item \emph{Negação}: $\neg \phi_1$
        \item \emph{Conjunção}: $\phi_1 \wedge ... \wedge \phi_n$
        \item \emph{Disjunção}: $\phi_1 \vee ... \vee \phi_n$
        \item \emph{Implicação}: $\phi_1 \rightarrow \phi_2$
        \item \emph{Equivalência}: $\phi_1 \leftrightarrow \phi_2$
    \end{enumerate}
    Em todos os casos acima, dizemos que $\phi_i$ é \emph{subfórmula imediata} de $\phi$, para $i=1,...,n$.
    
    Denotamos a conjunção vazia ($\phi_1 \wedge ... \wedge \phi_n$ com $n=0$) por $\top$, a disjunção vazia por $\bot$ e o conjunto das fórmulas por $\mathcal{L}$.
    
    Denotamos ainda por $SFI(\phi)$ o conjunto das subfórmulas imediatas de $\phi$.
\end{definition}

\begin{example}
	São fórmulas:
	\begin{itemize}
		\item $\phi = (p \rightarrow q) \rightarrow \neg s$
		\item $\psi = (p \vee q) \leftrightarrow (r \wedge s)$
		\item $\xi  = \neg(p \rightarrow q)$
	\end{itemize}
	
	Note ainda que $p \rightarrow q$ é subfórmula imediata de $\phi$ e de $\xi$.
\end{example}

\begin{definition}\textbf{(Semântica)}
	
	Dizemos que $\mathbb{v}_0$ é uma \emph{valoração booleana} se $\mathbb{v}_0$ é uma função tal que\break $\mathbb{v}_0 : \mathcal{P} \longmapsto \{V,F\}$.
    
    Seja $\mathbb{v}_0$ uma valoração booleana. Dizemos que $\mathbb{v}$ é uma \emph{interpretação definida por $\mathbb{v}_0$} se $\mathbb{v}$ é uma função tal que $\mathbb{v} : \mathcal{L} \longmapsto \{V,F\}$ e:
    \begin{enumerate}
        \item Se $\phi_1 \in \mathcal{P}$, então $\mathbb{v}(\phi_1) = \mathbb{v}_0(\phi_1)$.
        \item $\mathbb{v}(\neg \phi_1) = V$ se, e somente se, $\mathbb{v}(\phi_1) = F$.
        \item $\mathbb{v}(\phi_1 \wedge ... \wedge \phi_n) = V$ se, e somente se, $\mathbb{v}(\phi_i) = V$, para todo $i$.
        \item $\mathbb{v}(\phi_1 \vee ... \vee \phi_n) = V$ se, e somente se, $\mathbb{v}(\phi_i) = V$, para algum $i$.
        \item $\mathbb{v}(\phi_1 \rightarrow \phi_2) = V$ se, e somente se, $\mathbb{v}(\phi_1) = F$ ou $\mathbb{v}(\phi_2) = V$.
        \item $\mathbb{v}(\phi_1 \leftrightarrow \phi_2) = V$ se, e somente se, $\mathbb{v}(\phi_1) = \mathbb{v}(\phi_2)$.
        \item $\mathbb{v}(\top) = V$.
        \item $\mathbb{v}(\bot) = F$.
    \end{enumerate}
\end{definition}

\begin{example}
    Seja a interpretação $\mathbb{v}$ definida por $\mathbb{v}_0 = \{(p,V),(q,F),(r,V),(s,V)\}$ e considere a fórmula $\phi = \neg((p \vee (q \wedge r \wedge s)) \leftrightarrow (q \rightarrow \neg s))$. Temos que:
    \begin{enumerate}
        \item $\mathbb{v}(q \wedge r \wedge s) = F$
        \item $\mathbb{v}(p \vee (q \wedge r \wedge s)) = V$
        \item $\mathbb{v}(\neg s) = F$
        \item $\mathbb{v}(q \rightarrow \neg s) = V$
        \item $\mathbb{v}((p \vee (q \wedge r \wedge s)) \leftrightarrow (q \rightarrow \neg s)) = V$
        \item $\mathbb{v}(\phi) = F$
    \end{enumerate}
\end{example}

No que segue, usaremos tão somente \emph{interpretação}, ao invés de \emph{interpretação definida por $\mathbb{v}_0$}.

\begin{definition}
	Se existe uma interpretação $\mathbb{v}$ tal que $\mathbb{v}(\phi) = V$, então dizemos que $\mathbb{v}$ \emph{satisfaz} $\phi$, ou ainda, que $\phi$ é \emph{satisfatível}. De maneira análoga, se $\mathbb{v}$ é tal que $\mathbb{v}(\phi) = F$, então dizemos que $\mathbb{v}$ \emph{falsifica} $\phi$, ou ainda, que $\phi$ é \emph{falsificável}.
	
	Se toda interpretação satisfaz $\phi$, então dizemos que $\phi$ é uma \emph{tautologia}. Por outro lado, se toda interpretação falsifica $\phi$, ou seja, se nenhuma interpretação satisfaz $\phi$ (logo $\phi$ não é satisfatível), então dizemos que $\phi$ é uma \emph{contradição}, ou que $\phi$ é \emph{insatisfatível}.
	
	Se $\phi$ é simultaneamente satisfatível e falsificável, então dizemos que $\phi$ é uma \emph{contingência}.
\end{definition}

\begin{example}
    São tautologias:
    \begin{itemize}
        \item $\phi \vee \neg \phi$
        \item $\phi \rightarrow \phi$
        \item $\phi \leftrightarrow \phi$
        \item $\top$
    \end{itemize}
    São contradições:
    \begin{itemize}
        \item $\phi \wedge \neg \phi$
        \item $\phi \leftrightarrow \neg \phi$
        \item $\bot$
    \end{itemize}
    São contingências:
    \begin{itemize}
    	\item $p$
    	\item $\neg p$
    	\item $p \wedge q$
    	\item $p \vee q$
    	\item $p \rightarrow q$
    	\item $p \leftrightarrow q$
    \end{itemize}
\end{example}

\section{Problemas da lógica proposicional}
\label{problemas_da_logica}

\indent

Apresentamos nesta seção os principais problemas envolvendo a lógica proposicional, que são o alvo deste trabalho.

\begin{definition}
	Seja $L$ um conjunto de cadeias sobre um alfabeto. Se nos referimos a $L$ como um \emph{problema}, referimo-nos ao problema de decidir se uma dada cadeia $w$ pertence a $L$. Ou seja, referimo-nos a $L$ como um \emph{problema de decisão}.
	
	Dizemos que um problema $L$ é \emph{decidível} quando existe um algoritmo $A$ tal que:
	\begin{enumerate}
		\item $A$ realiza um número finito de passos sobre a entrada $w$ e responde ``sim'', para toda cadeia $w \in L$.
		\item $A$ realiza um número finito de passos sobre a entrada $w$ e responde ``não'', para toda cadeia $w \notin L$.
	\end{enumerate}
	Neste caso, dizemos que $A$ \emph{decide} $L$, ou ainda que $A$ é um \emph{decisor} para $L$.
	
	Denotamos por $\overline{L}$ o complemento de $L$, ou seja, o conjunto $\{w \mid w \notin L \}$.
\end{definition}

\begin{definition}
	Definimos $\text{SAT} = \{\phi \in \mathcal{L} \mid \phi \text{ é satisfatível} \}$ como o problema da \emph{satisfatibilidade} e $\text{UNSAT} = \{\phi \in \mathcal{L} \mid \phi \text{ é insatisfatível} \} = \{\phi \in \mathcal{L} \mid \phi \notin \text{SAT} \} = \overline{SAT}$ como o problema da \emph{insatisfatibilidade}.
	
	Definimos ainda $\text{VAL} = \{\phi \in \mathcal{L} \mid \phi \text{ é tautologia} \}$ como o problema da \emph{validade}.
	
	Observe que $\text{UNSAT} = \{\phi \in \mathcal{L} \mid \phi \text{ é contradição} \}$.
\end{definition}

O conceito de \emph{fórmula válida} é usualmente definido através do conceito de \emph{consequência\break lógica} \cite{kleene68book}. Como estes dois conceitos não são necessários para este trabalho, não incluímos suas definições neste texto. Entretanto, é possível mostrar que o conjunto das tautologias é igual ao conjunto das fórmulas válidas. Por esta razão e por ser o uso mais famoso, referimo-nos ao problema de decidir se uma fórmula é uma tautologia por \emph{problema da validade}.

Davis et al. apresentam um algoritmo que decide SAT \cite{davis1960computing}. Além disso, é claro que se um problema é decidível, então o seu complemento também é. Isto é, com um algoritmo que decide SAT, é claro que temos um algoritmo para decidir UNSAT. De forma geral, podemos dizer que um problema decidível e seu complemento são \emph{redutíveis} um ao outro, ou seja, podemos construir um decisor para $\overline{L}$ usando um decisor para $L$ e vice-versa.

Mostramos agora que SAT e VAL são redutíveis um ao outro, reduzindo VAL a UNSAT e vice-versa. O teorema que apresentamos a seguir é útil nesta tarefa.

\begin{theorem}
	\label{negacoes}
	Se $\phi$ é uma:
	\begin{enumerate}
		\item tautologia, então $\neg \phi$ é uma contradição.
		\item contradição, então $\neg \phi$ é uma tautologia.
		\item contingência, então $\neg \phi$ é uma contingência.
	\end{enumerate}
\end{theorem}

\begin{prova}
Se $\phi$ é uma tautologia, então $\mathbb{v}(\phi) = V, \forall \mathbb{v}$. Logo $\mathbb{v}(\neg \phi) = F, \forall \mathbb{v}$. Portanto, $\neg \phi$ é uma contradição.

Se $\phi$ é uma contradição, então $\mathbb{v}(\phi) = F, \forall \mathbb{v}$. Logo $\mathbb{v}(\neg \phi) = V, \forall \mathbb{v}$. Portanto, $\neg \phi$ é uma tautologia.

Se $\phi$ é uma contingência, então existem interpretações $\mathbb{v}_1,\mathbb{v}_2$ tais que $\mathbb{v}_1(\phi) = V$ e $\mathbb{v}_2(\phi) = F$. Logo, $\mathbb{v}_1(\neg \phi) = F$ e $\mathbb{v}_2(\neg \phi) = V$. Portanto, $\neg \phi$ é uma contingência.
\end{prova}

\begin{theorem}
	\label{satval}
	SAT e VAL são redutíveis um ao outro.
\end{theorem}

\begin{prova}
Agora, seja $A_1$ um decisor para UNSAT e considere o seguinte algoritmo, que chamaremos de $R_1$: ``Sobre a entrada $\phi \in \mathcal{L}$, dê a resposta de $A_1$ sobre a entrada $\neg \phi$.''

Vamos examinar o comportamento de $R_1$ para todas as possibilidades, ou seja, $\forall \phi \in \mathcal{L}$.

Quando $\phi$ é uma contradição ou uma contingência, do Teorema \ref{negacoes}, temos que $\neg \phi$ é uma tautologia ou uma contingência, respectivamente. Em ambos os casos, $R_1$ responde ``não'', pois $A_1$ responde ``não'' sobre a entrada $\neg \phi$. Observe ainda que, em ambos os casos, $\phi \notin \text{VAL}$.

Quando $\phi$ é uma tautologia (logo $\phi \in \text{VAL}$), temos que $\neg \phi$ é uma contradição. Neste caso, $R_1$ responde ``sim'', pois $A_1$ responde ``sim'' sobre a entrada $\neg \phi$.

Mostramos então que $R_1$ decide VAL, ou seja, VAL é redutível a UNSAT.

Seja agora $A_2$ um decisor para VAL e considere o seguinte algoritmo, que chamaremos de $R_2$: ``Sobre a entrada $\phi \in \mathcal{L}$, dê a resposta de $A_2$ sobre a entrada $\neg \phi$.''

Quando $\phi$ é uma tautologia ou uma contingência (ou seja, $\phi \notin \text{UNSAT}$), temos que $\neg \phi$ é uma contradição ou uma contingência, respectivamente. Em ambos os casos, $R_2$ responde ``não'', pois $A_2$ responde ``não'' sobre a entrada $\neg \phi$.

Finalmente, quando $\phi$ é uma contradição, ou seja, quando $\phi \in \text{UNSAT}$, temos que $\neg \phi$ é uma tautologia. Neste caso, $R_2$ responde ``sim'', pois $A_2$ responde ``sim'' sobre a entrada $\neg \phi$.

Mostramos então que $R_2$ decide UNSAT, ou seja, UNSAT é redutível a VAL.

Com as \emph{reduções} $R_1$ e $R_2$ e com o fato de que SAT e UNSAT são redutíveis um ao outro, mostramos que VAL e SAT são também redutíveis um ao outro.
\end{prova}

\section{Formas normais}

\indent

Esta seção apresenta as definições e resultados que envolvem formas normais, conceito chave para este trabalho.

\begin{definition}
	Seja $\phi$ uma fórmula. Definimos $tam(\phi)$, o \emph{tamanho} de $\phi$, como o seguinte número:
	\begin{enumerate}
		\item Se $\phi \in \mathcal{P}$, então $tam(\phi) = 1$.
		\item $tam(\neg \phi) = 1 + tam(\phi)$.
		\item $tam(\phi_1 \wedge ... \wedge \phi_n) = tam(\phi_1 \vee ... \vee \phi_n) = n - 1 + \sum_i tam(\phi_i)$.
		\item $tam(\phi_1 \rightarrow \phi_2) = tam(\phi_1 \leftrightarrow \phi_2) = 1 + tam(\phi_1) + tam(\phi_2)$.
		\item $tam(\top) = tam(\bot) = 1$.
	\end{enumerate}
\end{definition}

\begin{example}
	Seja $\phi = p \rightarrow (\neg r \vee (q \leftrightarrow s))$. Então
	\begin{equation*}
	\begin{split}
	tam(\phi) & = 1 + tam(p) + tam(\neg r \vee (q \leftrightarrow s))\\
	& = 1 + 1 + (1 + tam(\neg r) + tam(q \leftrightarrow s))\\
	& = 1 + 1 + (1 + (1 + tam(r)) + (1 + tam(q) + tam(s)))\\
	& = 1 + 1 + (1 + (1 + 1) + (1 + 1 + 1))\\
	& = 8\\
	\end{split}
	\end{equation*}
\end{example}

\begin{definition}
	Dizemos que $\phi$ é \emph{subfórmula} de $\psi$, escrito $\phi \sqsubseteq \psi$, se, e somente se, alguma das possibilidades ocorre:
	\begin{enumerate}
		\item $\phi = \psi$.
		\item $\phi$ é subfórmula imediata de $\psi$.
		\item $\phi$ é subfórmula de $\xi$ e $\xi$ é subfórmula imediata de $\psi$.
	\end{enumerate}
	
	Denotamos o conjunto $\{\psi \mid \psi \sqsubseteq \phi \}$ das subfórmulas de $\phi$ por $SF(\phi)$.
	
	Se $\phi \sqsubseteq \psi$ e $\phi \neq \psi$, então dizemos que $\phi$ é \emph{subfórmula própria} de $\psi$ e escrevemos $\phi \sqsubset \psi$.
	
	Denotamos o conjunto $\{\psi \mid \psi \sqsubset \psi \}$ das subfórmulas próprias de $\phi$ por $SFP(\phi)$.
\end{definition}

\begin{example}
	Considere a fórmula $\phi = \neg((p \vee (q \wedge r \wedge s)) \leftrightarrow (q \rightarrow \neg s))$. Note que:
	\begin{itemize}
		\item A única subfórmula imediata de $\phi$ é $\phi_1 = (p \vee (q \wedge r \wedge s)) \leftrightarrow (q \rightarrow \neg s)$.
		\item $SF(\phi) = \{p,q,r,s,\neg s,q \wedge r \wedge s,q \rightarrow \neg s,p \vee (q \wedge r \wedge s),\phi_1,\phi \}$.
		\item $SFP(\phi) = SF(\phi) - \{\phi \}$; e, por definição, isto é verdade para toda $\phi$.
	\end{itemize}
\end{example}

\begin{definition}
	Uma \emph{posição} é uma sequência finita de números naturais. Usaremos as notações alternativas $\varepsilon$, para a posição vazia $()$, e $a_1.\cdots.a_n$, para a posição $(a_1,\cdots,a_n)$, onde $n \in \mathbb{N} \cup \{0\}$. Além disso, se $\pi = a_1.\cdots.a_n$ é uma posição e $i$ é um número natural, então $i.\pi$ denota a posição $i.a_1.\cdots.a_n$ e $\pi.i$ denota a posição $a_1.\cdots.a_n.i$.
	
    Definimos o \emph{conjunto de posições} de uma fórmula $\phi$, $pos(\phi)$, da seguinte maneira:
    \begin{enumerate}
        \item Se $\phi \in \mathcal{P}$, então $pos(\phi) = \{\varepsilon\}$.
        \item Se $\phi$ é da forma $\neg \phi_1$, $\phi_1 \wedge ... \wedge \phi_n$, $\phi_1 \vee ... \vee \phi_n$, $\phi_1 \rightarrow \phi_2$, ou $\phi_1 \leftrightarrow \phi_2$, então $$pos(\phi) = \{\varepsilon\} \cup \left(\bigcup_i \; \{i.\pi \mid \pi \in pos(\phi_i)\}\right)$$
    \end{enumerate}
    
    Agora, definimos a \emph{subfórmula de} $\phi$ \emph{começando na posição} $\pi$, escrito $\phi|_\pi$, da seguinte forma:
    \begin{enumerate}
        \item Se $\pi = \varepsilon$, então $\phi|_\pi = \phi$.
        \item Se $\phi$ é da forma $\neg \phi_1$, $\phi_1 \wedge ... \wedge \phi_n$, $\phi_1 \vee ... \vee \phi_n$, $\phi_1 \rightarrow \phi_2$, ou $\phi_1 \leftrightarrow \phi_2$, e $\pi$ é da forma $i.\pi'$, para algum natural $i$ e alguma posição $\pi' \in pos(\phi_i)$, então $\phi|_\pi = \phi_i|_{\pi'}$.
    \end{enumerate}
\end{definition}

\begin{example}
    Seja $\phi = p \vee (q \wedge \neg r)$. Observe que:
    \begin{equation*}
        \begin{split}
            pos(\neg r) & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in pos(r)\} \\
                        & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in \{\varepsilon\}\} \\
                        & = \{\varepsilon,1\}
        \end{split}
    \end{equation*}
    \begin{equation*}
        \begin{split}
            pos(q \wedge \neg r) & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in pos(q)\} \cup \{2.\pi \mid \pi \in pos(\neg r)\} \\
                                 & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in \{\varepsilon\}\} \cup \{2.\pi \mid \pi \in \{\varepsilon,1\}\} \\
                                 & = \{\varepsilon,1,2,2.1\}
        \end{split}
    \end{equation*}
    \begin{equation*}
        \begin{split}
            pos(\phi) & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in pos(p)\} \cup \{2.\pi \mid \pi \in pos(q \wedge \neg r)\} \\
                      & = \{\varepsilon\} \cup \{1.\pi \mid \pi \in \{\varepsilon\}\} \cup \{2.\pi \mid \pi \in \{\varepsilon,1,2,2.1\}\} \\
                      & = \{\varepsilon,1,2,2.1,2.2,2.2.1\}
        \end{split}
    \end{equation*}
    
    Além disso, note que:
    \begin{itemize}
        \item $\phi|_{\varepsilon} = \phi = p \vee (q \wedge \neg r)$
        \item $\phi|_{1} = p|_{\varepsilon} = p$
        \item $\phi|_{2} = (q \wedge \neg r)|_{\varepsilon} = q \wedge \neg r$
        \item $\phi|_{2.1} = (q \wedge \neg r)|_{1} = q|_{\varepsilon} = q$
        \item $\phi|_{2.2} = (q \wedge \neg r)|_{2} = (\neg r)|_{\varepsilon} = \neg r$
        \item $\phi|_{2.2.1} = (q \wedge \neg r)|_{2.1} = (\neg r)|_{1} = r|_{\varepsilon} = r$
    \end{itemize}
    
    Observe que $\{\phi|_\pi \mid \pi \in pos(\phi)\} = SF(\phi)$.
\end{example}

\begin{definition}
    Definimos a \emph{polaridade da subfórmula de} $\phi$ \emph{começando na posição} $\pi$, escrito $pol(\phi,\pi)$, como o seguinte número:
    \begin{enumerate}
        \item $pol(\phi,\varepsilon) = 1$.
        \item Se $\phi|_\pi$ é da forma $\neg \phi_1$, então $pol(\phi,\pi.1) = -pol(\phi,\pi)$.
        \item Se $\phi|_\pi$ é da forma $\phi_1 \wedge ... \wedge \phi_n$, ou $\phi_1 \vee ... \vee \phi_n$, então $pol(\phi,\pi.i) = pol(\phi,\pi)$, para $i=1,...,n$.
        \item Se $\phi|_\pi$ é da forma $\phi_1 \rightarrow \phi_2$, então $pol(\phi,\pi.1) = -pol(\phi,\pi)$ e $pol(\phi,\pi.2) = pol(\phi,\pi)$.
        \item Se $\phi|_\pi$ é da forma $\phi_1 \leftrightarrow \phi_2$, então $pol(\phi,\pi.1) = pol(\phi,\pi.2) = 0$.
    \end{enumerate}
\end{definition}

\begin{example}
    Seja $\phi = (p \rightarrow q) \rightarrow \neg(p \leftrightarrow (r \vee s))$. Temos que:
    \begin{itemize}
        \item $pol(\phi,\varepsilon) = 1$
        \item $pol(\phi,1) = -1$
        \item $pol(\phi,1.1) = 1$
        \item $pol(\phi,1.2) = -1$
        \item $pol(\phi,2) = 1$
        \item $pol(\phi,2.1) = -1$
        \item $pol(\phi,2.1.1) = 0$
        \item $pol(\phi,2.1.2) = 0$
        \item $pol(\phi,2.1.2.1) = 0$
        \item $pol(\phi,2.1.2.2) = 0$
    \end{itemize}
\end{example}

\begin{definition}
	Denotamos por $$\phi \longmapsto \psi$$ a \emph{regra de reescrita} que transforma uma fórmula da forma de $\phi$ em $\psi$.
	
	Se uma regra de reescrita transforma $\phi$ em $\psi$, dizemos que esta regra:
	\begin{enumerate}
		\item \emph{preserva equivalência} se, e somente se, $\mathbb{v}(\phi) = \mathbb{v}(\psi), \forall \mathbb{v}$, ou seja, $\phi \leftrightarrow \psi \in \text{VAL}$.
		\item \emph{preserva satisfatibilidade} se, e somente se, $\phi \in \text{SAT} \iff \psi \in \text{SAT}$.
	\end{enumerate}
\end{definition}

\begin{theorem}
	\label{teo_flattening}
	Seja $\phi$ da forma $\phi_1 \wedge ... \wedge \phi_n$ e $\phi_1$ da forma $\psi_1 \wedge ... \wedge \psi_k$. Então a transformação $$\phi \longmapsto \psi_1 \wedge ... \wedge \psi_k \wedge \phi_2 \wedge ... \wedge \phi_n$$ que chamaremos de \emph{aplainamento}, preserva equivalência. O mesmo vale para disjunções.
\end{theorem}

O Teorema \ref{teo_flattening} é apenas uma formalização do fato que podemos considerar uma conjunção de conjunções como uma única conjunção, e que o mesmo vale para disjunções. Usaremos este fato mais adiante, no Capítulo \ref{cap_resultados}.

\begin{definition}
    Dizemos que uma fórmula $\phi$ está na \emph{forma normal negada} (FNN) se, e somente se, $\phi$ não contém implicações, não contém equivalências e negações ocorrem somente em símbolos proposicionais.
\end{definition}

\begin{theorem}
    \label{fnn_theorem}
    As transformações
    \begin{enumerate}
        \item $\neg \neg \phi_1 \longmapsto \phi_1$ (eliminação de dupla negação)
        \item $\neg(\phi_1 \wedge ... \wedge \phi_n) \longmapsto \neg \phi_1 \vee ... \vee \neg \phi_n$ (De Morgan)
        \item $\neg(\phi_1 \vee ... \vee \phi_n) \longmapsto \neg \phi_1 \wedge ... \wedge \neg \phi_n$ (De Morgan)
        \item $\phi_1 \rightarrow \phi_2 \longmapsto \neg \phi_1 \vee \phi_2$
        \item Se $\phi|_\pi$ é da forma $\phi_1 \leftrightarrow \phi_2$, então
        \begin{enumerate}
        	\item $\phi|_\pi \longmapsto (\phi_1 \rightarrow \phi_2) \wedge (\phi_2 \rightarrow \phi_1)$, se $pol(\phi,\pi) = 1$
        	\item $\phi|_\pi \longmapsto (\phi_1 \wedge \phi_2) \vee (\neg \phi_2 \wedge \neg \phi_1)$, se $pol(\phi,\pi) = -1$
        \end{enumerate}
    \end{enumerate}
    preservam equivalência e produzem fórmulas na FNN.
\end{theorem}

A prova do Teorema \ref{fnn_theorem} segue por indução na estrutura de uma fórmula.

A transformação de equivalências dependente de polaridade do Teorema \ref{fnn_theorem} evita que tautologias difíceis de detectar apareçam nas fórmulas transformadas, como mostra o Exemplo \ref{exemplo_fnn_fnc}, dado por Nonnengart et al. \cite{nonnengart2001computing}. Observe que não é necessário considerar o caso em que a polaridade é zero, pois, para evitar este caso, basta transformar equivalências em posições mais curtas primeiro.

\begin{definition}
	Dizemos que $\phi$ é um \emph{literal} se, e somente se, $\phi \in \mathcal{P}$, ou $\phi$ é da forma $\neg p$, onde $p \in \mathcal{P}$.
	
	Dizemos que uma disjunção de literais é uma \emph{cláusula}.
	
    Dizemos que uma fórmula $\phi$ está na \emph{forma normal clausal} (FNC) se, e somente se, $\phi$ é uma conjunção de cláusulas.
\end{definition}

\begin{theorem}
	\label{fnc_theorem}
    A transformação $$\phi \vee \left( \bigwedge_i \phi_i \right) \longmapsto \bigwedge_i \left( \phi \vee \phi_i \right)$$ chamada de \emph{distribuição}, preserva equivalência e, se aplicada a fórmulas na FNN, produz fórmulas na FNC.
\end{theorem}

A prova do Teorema \ref{fnc_theorem} segue por indução na estrutura de uma fórmula.

\begin{example}
	\label{exemplo_fnn_fnc}
    Considere $\phi$ da forma $\neg(\phi_1 \leftrightarrow \phi_2)$. Aplicando as transformações dos Teoremas \ref{fnn_theorem} e \ref{fnc_theorem} à exaustão, começando pela transformação do item 5.a do Teorema \ref{fnn_theorem} e então aplicando distribuição, temos:
    \begin{equation*}
        \begin{split}
            \neg(\phi_1 \leftrightarrow \phi_2) & \longmapsto \neg((\phi_1 \rightarrow \phi_2) \wedge (\phi_2 \rightarrow \phi_1)) \\
                 & \longmapsto \neg((\neg \phi_1 \vee \phi_2) \wedge (\neg \phi_2 \vee \phi_1)) \\
                 & \longmapsto \neg(\neg \phi_1 \vee \phi_2) \vee \neg(\neg \phi_2 \vee \phi_1) \\
                 & \longmapsto (\neg \neg \phi_1 \wedge \neg \phi_2) \vee (\neg \neg \phi_2 \wedge \neg \phi_1) \\
                 & \longmapsto (\phi_1 \wedge \neg \phi_2) \vee (\phi_2 \wedge \neg \phi_1) \\
                 & \longmapsto ((\phi_1 \wedge \neg \phi_2) \vee \phi_2) \wedge ((\phi_1 \wedge \neg \phi_2) \vee \neg \phi_1) \\
                 & \longmapsto (\phi_1 \vee \phi_2) \wedge (\neg \phi_2 \vee \phi_2) \wedge (\phi_1 \vee \neg \phi_1) \wedge (\neg \phi_2 \vee \neg \phi_1)
        \end{split}
    \end{equation*}
    Se $\phi_1,\phi_2 \in \mathcal{P}$, então a última fórmula já está na FNC, de modo que é fácil identificar e remover as tautologias $\neg \phi_2 \vee \phi_2$ e $\phi_1 \vee \neg \phi_1$. Caso contrário, as transformações aplicadas à exaustão transformam $\neg \phi_i$ em uma fórmula $\psi \neq \neg \phi_i$, dificultando identificar e remover as tautologias mencionadas.
    
    Considere agora uma transformação que leva em conta polaridade, ou seja, desta vez começamos com a transformação do item 5.b do Teorema \ref{fnn_theorem}.
    \begin{equation*}
        \begin{split}
            \neg(\phi_1 \leftrightarrow \phi_2) & \longmapsto \neg((\phi_1 \wedge \phi_2) \vee (\neg \phi_1 \wedge \neg \phi_2)) \\
                 & \longmapsto \neg(\phi_1 \wedge \phi_2) \wedge \neg(\neg \phi_1 \wedge \neg \phi_2) \\
                 & \longmapsto (\neg \phi_1 \vee \neg \phi_2) \wedge (\neg \neg \phi_1 \vee \neg \neg \phi_2) \\
                 & \longmapsto (\neg \phi_1 \vee \neg \phi_2) \wedge (\phi_1 \vee \phi_2) \\
        \end{split}
    \end{equation*}
    Agora, o número de passos de transformação é menor, o tamanho da fórmula resultante é menor e as tautologias indesejadas não aparecem.
    
    Por fim, note que os fatos ilustrados por este exemplo ocorrem para qualquer subfórmula da forma $\phi_1 \leftrightarrow \phi_2$ ocorrendo com polaridade negativa em qualquer posição de $\phi$, $\forall \phi,\phi_1,\phi_2 \in \mathcal{L}$.
\end{example}

\section{Renomeamento}

\indent

Nesta seção introduzimos a transformação feita com renomeamento, que utilizamos para reduzir o tamanho de uma fórmula neste trabalho.

\begin{definition}
	Sejam $\phi$ e $\psi$ fórmulas tais que $\psi \in SFP(\phi)$ e $p \in \mathcal{P}$ tal que $p$ não ocorre em $\phi$. A \emph{substituição de} $\psi$ \emph{por} $p$ \emph{em} $\phi$, denotada por $rep(\phi,\psi,p)$, é a fórmula $\phi$ com todas as ocorrências de $\psi$ trocadas por $p$.
	
	Um \emph{renomeamento de $\phi$} é um conjunto de subfórmulas próprias de $\phi$.
	
	Seja $R$ um renomeamento de $\phi$. Uma \emph{substituição de $R$ em $\phi$} é uma função injetora $s : R \longmapsto \mathcal{P}$ tal que $p$ não ocorre em $\phi$, $\forall p \in \text{Im}(s)$.
	
	Seja $s = \{(\phi_1,p_1),...,(\phi_n,p_n) \}$ uma substituição de $R = \{\phi_1,...,\phi_n \}$ em $\phi$. Definimos
	\[
	rep(\phi,s) =
	\begin{cases} 
	\hfill \phi    \hfill & \text{ se $n=0$} \\
	\hfill rep(rep(\phi,\phi_1,p_1),\{(\phi_2,p_2),...,(\phi_n,p_n)\}) \hfill & \text{ se $n > 0$} \\
	\end{cases}
	\]
\end{definition}

\begin{example}
	Seja $\phi = (p \vee q) \rightarrow (r \wedge (p \vee q) \wedge (p \wedge q))$ e $s = \{(p \vee q,a),(p \wedge q,b)\}$. Então $$rep(\phi,s) = a \rightarrow (r \wedge a \wedge b)$$
\end{example}

\begin{definition}
	Sejam $\phi$ e $\psi$ tais que $\psi \sqsubseteq \phi$ e $s$ uma substituição em $\phi$ tal que $(\psi,p) \in s$. Denote ainda $rep(\psi,s-\{(\psi,p)\})$ por $\xi$. Definimos
	\[
	def(\phi,\psi,s) =
	\begin{cases} 
	\hfill p \rightarrow \xi \hfill     & \text{se } pol(\phi,\pi) = 1, \forall \pi \in pos(\phi) \text{ tal que } \phi|_\pi = \psi\\
	\hfill \xi \rightarrow p \hfill     & \text{se } pol(\phi,\pi) = -1, \forall \pi \in pos(\phi) \text{ tal que } \phi|_\pi = \psi\\
	\hfill p \leftrightarrow \xi \hfill & \text{caso contrário}\\
	\end{cases}
	\]
	como a \emph{definição de $\psi$ em $\phi$ segundo $s$}.
\end{definition}

\begin{theorem}
	\label{struct_preserving}
	Seja $s = \{(\phi_1,p_1),...,(\phi_n,p_n) \}$ uma substituição de $R = \{\phi_1,...,\phi_n \}$ em $\phi$, onde $R$ é um renomeamento de $\phi$. Então, a transformação $$\phi \longmapsto \mathcal{R}(\phi,s)$$ onde $$\mathcal{R}(\phi,s) = rep(\phi,s) \wedge def(\phi,\phi_1,s) \wedge ... \wedge def(\phi,\phi_n,s)$$
    que chamaremos de \emph{transformação por renomeamento}, preserva satisfatibilidade.
\end{theorem}

Plaisted et al. provam o Teorema \ref{struct_preserving} \cite{plaisted1986structure}.

\begin{example}
	\label{exemplo_renaming}
    Considere $\phi = (p \leftrightarrow q) \leftrightarrow (p \leftrightarrow q)$ e $s = \{(p \leftrightarrow q, r) \}$. Então $$\mathcal{R}(\phi,s) = (r \leftrightarrow r) \wedge (r \leftrightarrow (p \leftrightarrow q))$$
    
    Note que tanto $\phi$ quanto $\mathcal{R}(\phi,s)$ são satisfatíveis, mas que $\phi$ é uma tautologia da forma $\psi \leftrightarrow \psi$, enquanto $\mathcal{R}(\phi,s)$ é uma contingência, pois:
    \begin{enumerate}
    	\item Se $\mathbb{v}(r) = V$, $\mathbb{v}(p) = V$ e $\mathbb{v}(q) = V$, então $\mathbb{v}(\mathcal{R}(\phi,s)) = V$.
    	\item Se $\mathbb{v}(r) = V$, $\mathbb{v}(p) = V$ e $\mathbb{v}(q) = F$, então $\mathbb{v}(\mathcal{R}(\phi,s)) = F$.
    \end{enumerate}
\end{example}

O Exemplo \ref{exemplo_renaming} mostra que transformações que preservam satisfatibilidade, diferentemente das que preservam equivalência, podem não preservar o significado de uma fórmula em todas as interpretações. No entanto, isto não é um obstáculo se quisermos determinar precisamente se uma fórmula é uma tautologia, uma contradição ou uma contingência. Isto segue do fato que mostramos na Seção \ref{problemas_da_logica}: SAT, UNSAT e VAL são todos problemas redutíveis uns aos outros. Se uma transformação preserva satisfatibilidade, então é claro que as respostas de decisores para SAT e UNSAT são preservadas por esta transformação. Neste caso, as respostas das reduções que mostramos anteriormente também são preservadas. Portanto, com os procedimentos apropriados, é perfeitamente possível determinar o tipo de uma fórmula através de sua transformação, ou da transformação de sua negação. Este resultado é fundamental para que possamos utilizar renomeamento para obter fórmulas pequenas.

\section{Reduzindo o número de cláusulas}

\indent

Apresentamos nesta seção o algoritmo proposto por Boy de la Tour para obter um renomeamento que reduz o número de cláusulas geradas por uma fórmula.

\begin{definition}
	Denotamos por $p(\phi)$ o \emph{número de cláusulas} da fórmula obtida por aplicar as transformações dos Teoremas \ref{fnn_theorem} e \ref{fnc_theorem} à exaustão na fórmula $\phi$. Denotamos ainda $p(\neg \phi)$ por $\overline{p}(\phi)$.
\end{definition}

O número $p(\phi)$ pode ser calculado pela Tabela \ref{numerop} \cite{de1992optimality}.

\tabela{Número de cláusulas de uma fórmula}{numerop}{c|c|c}{
	Forma de $\phi$                   & $p(\phi)$                                                       & $\overline{p}(\phi)$                                            \\ \hline
	$\neg \phi_1$                     & $\overline{p}(\phi_1)$                                          & $p(\phi_1)$                                                     \\
	$\phi_1 \wedge ... \wedge \phi_n$ & $\sum_{i=1}^n p(\phi_i)$                                        & $\prod_{i=1}^n \overline{p}(\phi_i)$                            \\
	$\phi_1 \vee ... \vee \phi_n$     & $\prod_{i=1}^n p(\phi_i)$                                       & $\sum_{i=1}^n \overline{p}(\phi_i)$                             \\
	$\phi_1 \rightarrow \phi_2$       & $\overline{p}(\phi_1)p(\phi_2)$                                 & $p(\phi_1)+\overline{p}(\phi_2)$                                \\
	$\phi_1 \leftrightarrow \phi_2$   & $\overline{p}(\phi_1)p(\phi_2) + \overline{p}(\phi_2)p(\phi_1)$ & $p(\phi_1)p(\phi_2) + \overline{p}(\phi_1)\overline{p}(\phi_2)$ \\
	$\phi \in \mathcal{P}$            & $1$                                                             & $1$                                                             \\
}

\begin{example}
	Considere a fórmula $\phi = (r \leftrightarrow s) \leftrightarrow (r \leftrightarrow s)$. Primeiro, seja $\phi_1 = r \leftrightarrow s$. Então $$p(\phi_1) = \overline{p}(r)p(s) + \overline{p}(s)p(r) = 1 \cdot 1 + 1 \cdot 1 = 2$$ e $$\overline{p}(\phi_1) = p(r)p(s) + \overline{p}(s)\overline{p}(r) = 1 \cdot 1 + 1 \cdot 1 = 2$$ Agora, $$p(\phi) = \overline{p}(\phi_1)p(\phi_1) + \overline{p}(\phi_1)p(\phi_1) = 2 \cdot 2 + 2 \cdot 2 = 8$$
\end{example}

Denotaremos ainda $p(\mathcal{R}(\phi,s))$ simplesmente por $p(\phi,R)$, onde $R = D(s)$ é o renomeamento associado à substituição $s$.

Agora, dada uma fórmula $\phi$, queremos escolher um renomeamento $R$ de $\phi$ tal que o número $p(\phi,R)$ seja o menor possível.

\begin{definition}
	Uma fórmula $\phi$ é dita uma \emph{árvore linear} se:
	\begin{enumerate}
		\item $\pi_1 \neq \pi_2 \implies \phi|_{\pi_1} \neq \phi|_{\pi_2}$; e
		\item $\phi$ está na FNN.
	\end{enumerate}
\end{definition}

O Algoritmo \ref{boydelatour}, apresentado por Boy de la Tour, encontra um renomeamento que produz o número ótimo (mínimo) de cláusulas, desde que $\phi$ seja uma árvore linear \cite{de1992optimality}, ou seja, desde que não ocorram repetições de subfórmulas e $\phi$ esteja na FNN. Seu custo de tempo é $O(|pos(\phi)|^2)$ determinístico no pior caso.

Os coeficientes $a$ e $b$ que aparecem no algoritmo são exatamente os números de vezes que os números $p(\psi)$ e $\overline{p}(\psi)$, respectivamente, são somados ao valor de $p(\phi)$. Em outras palavras, o algoritmo utiliza a forma irredutível de $p(\phi)$ em função de $p(\psi)$ e $\overline{p}(\psi)$: $$p(\phi) = a_\psi^\phi p(\psi) + b_\psi^\phi \overline{p}(\psi) + c$$ onde $c$ não depende de $p(\psi)$ ou $\overline{p}(\psi)$.

As escritas $\psi.p$ e $\psi.\overline{p}$ que aparecem no algoritmo representam inicialmente $p(\psi)$ e $\overline{p}(\psi)$, respectivamente. No entanto, se $\psi$ é incluída em $R$, sua contribuição para $p(\phi,R)$ muda. Para esta mudança ser refletida nos cálculos do algoritmo, os valores de $p(\psi)$ e $\overline{p}(\psi)$ são armazenados em campos da respectiva subfórmula e atualizados conforme a execução do algoritmo. As notações $\psi.p$ e $\psi.\overline{p}$ indicam estes campos. Note então que pode ocorrer em algum momento que $p(\psi) \neq \psi.p$ ou $\overline{p}(\psi) \neq \psi.\overline{p}$.

Os números $a_{\psi_i}^{\mathcal{R}(\phi,s)}$ e $b_{\psi_i}^{\mathcal{R}(\phi,s)}$ são computados a partir de $a = a_\psi^{\mathcal{R}(\phi,s)}$, $b = b_\psi^{\mathcal{R}(\phi,s)}$, $\psi_i.p$ e $\psi_i.\overline{p}$, seguindo as fórmulas da Tabela \ref{tabela_a_b}. A função $nbcl(\psi)$ retorna um par ordenado com os números de cláusulas de $\psi$ e $\neg \psi$, respectivamente. Este par ordenado é calculado a partir de $\psi_i.p$ e $\psi_i.\overline{p}$, ou seja, o estado atual do renomeamento é levado em consideração.

\tabela{Coeficientes $a$ e $b$ do Algoritmo \ref{boydelatour}}{tabela_a_b}{c|c|c}{
	Forma de $\psi$                        & $a_{\psi_i}^\phi$                                          & $b_{\psi_i}^\phi$                                          \\ \hline
	$\neg \psi_1$                          & $b_\psi^\phi$                                              & $a_\psi^\phi$                                              \\
	$\psi_1 \wedge ... \wedge \psi_n$      & $a_\psi^\phi$                                              & $b_\psi^\phi \prod_{j\neq i} \overline{p}(\psi_j)$         \\
	$\psi_1 \vee ... \vee \psi_n$          & $a_\psi^\phi \prod_{j\neq i} p(\psi_j)$                    & $b_\psi^\phi$                                              \\
	$\psi_1 \rightarrow \psi_2, i=1$       & $b_\psi^\phi$                                              & $a_\psi^\phi p(\psi_2)$                                    \\
	$\psi_1 \rightarrow \psi_2, i=2$       & $a_\psi^\phi \overline{p}(\psi_1)$                         & $b_\psi^\phi$                                              \\
	$\psi_1 \leftrightarrow \psi_2, j=3-i$ & $a_\psi^\phi \overline{p}(\psi_j) + b_\psi^\phi p(\psi_j)$ & $a_\psi^\phi p(\psi_j) + b_\psi^\phi \overline{p}(\psi_j)$ \\
	$\psi_i = \phi$                        & $1$                                                        & $0$                                                        \\
}

\begin{algorithm}
	\begin{algorithmic}[1]
		\State seja $R$ um conjunto vazio global
		\Function{$R\_rec$}{$\psi,a,b,r$}
		\If{$(\psi.p,\psi.\overline{p}) \neq (1,1)$}
		\If{$a \cdot \psi.p + b \cdot \psi.\overline{p} > a + b + if\_pos(r,\psi.p) + if\_pos(-r,\psi.\overline{p})$}
		\State $R \gets R \cup \{\psi \}$
		\State $R\_rec(\psi,if\_pos(r,1),if\_pos(-r,1),r)$
		\State $(\psi.p,\psi.\overline{p}) \gets (1,1)$
		\Else
		\State seja $SFI(\psi) = \{\psi_1,...,\psi_n \}$
		\For{$i$}{$1$}{$n$}
		\State $R\_rec(\psi_i,a_{\psi_i}^{\mathcal{R}(\phi,s)},b_{\psi_i}^{\mathcal{R}(\phi,s)},r \cdot pol(\psi,i))$
		\EndFor
		\State $(\psi.p,\psi.\overline{p}) \gets nbcl(\psi)$
		\EndIf
		\EndIf
		\EndFunction
		\Function{$if\_pos$}{$x,y$}
		\If{$x \geq 0$}
		\Return $y$
		\EndIf
		\Return $0$
		\EndFunction
		\ForAll{$\psi \in SF(\phi)$}
		\State $(\psi.p,\psi.\overline{p}) \gets (p(\psi),\overline{p}(\psi))$
		\EndFor
		\State $R\_rec(\phi,1,0,1)$
	\end{algorithmic}
	\caption{Algoritmo de Boy de la Tour para encontrar renomeamentos.}
	\label{boydelatour}
\end{algorithm}

\begin{example}
	Considere a fórmula $\phi = (x_1 \wedge x_2 \wedge x_3) \vee (y_1 \wedge y_2 \wedge y_3)$. Vamos executar $R\_rec(\phi,1,0,1)$.
	
	Na primeira chamada, a condição da Linha 3 é satisfeita, pois $\psi.p = 9$. A condição da Linha 4, no entanto, não é satisfeita, pois $a \cdot \psi.p + b \cdot \psi.\overline{p} = 9$ e $a + b + if\_pos(r,\psi.p) + if\_pos(-r,\psi.\overline{p}) = 10$. Portanto, a partir da Linha 9, $\psi_1 = x_1 \wedge x_2 \wedge x_3$ e $\psi_2 = y_1 \wedge y_2 \wedge y_3$ são subfórmulas imediatas de $\psi = \phi$. Na Linha 11, a função recursiva é chamada primeiro com $R\_rec(\psi_1,3,0,1)$.
	
	Na segunda chamada, temos que $\psi = x_1 \wedge x_2 \wedge x_3$. A condição da Linha 3 é satisfeita, pois $\psi.p = 3$. A condição da Linha 4 é satisfeita, pois $a \cdot \psi.p + b \cdot \psi.\overline{p} = 9$ e $a + b + if\_pos(r,\psi.p) + if\_pos(-r,\psi.\overline{p}) = 6$. Portanto, após a Linha 5, teremos $R = \{x_1 \wedge x_2 \wedge x_3 \}$. A Linha 6 é executada: $R\_rec(\psi,1,0,1)$.
	
	Na terceira chamada, a condição da Linha 3 é novamente satisfeita, pois $\psi.p$ ainda vale 3. A condição da Linha 4, no entanto, não é satisfeita, pois agora $a \cdot \psi.p + b \cdot \psi.\overline{p} = 3$ e $a + b + if\_pos(r,\psi.p) + if\_pos(-r,\psi.\overline{p}) = 4$. Portanto, a partir da Linha 9, temos $\psi_i = x_i$, para $i=1,2,3$. Assim, o algoritmo recursivo é chamado três vezes, para três literais. Mas é fácil ver que o algoritmo nunca escolhe literais para serem renomeados. Portanto, a terceira chamada retorna para a segunda, que está agora na Linha 7.
	
	De volta à segunda chamada, na Linha 7, os valores $\psi.p$ e $\psi.\overline{p}$ são atualizados. Isto encerra a segunda chamada recursiva.
	
	De volta à primeira chamada, a Linha 11 é agora executada com $R\_rec(\psi_2,1,0,1)$. No entanto, já vimos que uma chamada com estes parâmetros e $\psi$ da forma $y_1 \wedge y_2 \wedge y_3$ não modifica o conjunto $R$.
	
	O algoritmo termina então com $R = \{x_1 \wedge x_2 \wedge x_3 \}$.
	
	É fácil ver que $p(\phi,R) = 6$. Para ver que este resultado é ótimo, observe que basta considerar a inclusão das subfórmulas $\phi_1 = x_1 \wedge x_2 \wedge x_3$ e $\phi_2 = y_1 \wedge y_2 \wedge y_3$, pois qualquer outra subfórmula é um símbolo proposicional ou a própria $\phi$. Se incluímos ambas $\phi_1$ e $\phi_2$, a transformação gera 7 cláusulas. Se $R = \emptyset$, a fórmula permanece com 9 cláusulas. Se somente $\phi_1$, ou somente $\phi_2$ for incluída, a transformação gera 6 cláusulas. Logo, um renomeamento ótimo gera 6 cláusulas e o Algoritmo \ref{boydelatour} é capaz de encontrar um destes renomeamentos.
\end{example}

Note que o algoritmo proposto por Boy de la Tour é um \emph{algoritmo guloso}, ou seja, um algoritmo que faz uma série de escolhas que são ótimas em contextos locais \cite{CLRS09}. Mas, como dito anteriormente, Boy de la Tour prova que se a fórmula de entrada for uma árvore linear, então as escolhas ótimas locais de seu algoritmo são também ótimas no contexto global.

No Capítulo \ref{cap_algoritmo}, que vem a seguir, apresentamos um algoritmo de custo de tempo igualmente polinomial determinístico, mas que, para algumas famílias de fórmulas, encontra renomeamentos melhores que os construídos pelo Algoritmo \ref{boydelatour}.
