\indent

Lógicas têm sido utilizadas em Computação para representar e raciocinar sobre problemas. A representação se dá através de uma linguagem formal, que define a \emph{sintaxe} de uma lógica em particular, ou seja, a \emph{forma} dos enunciados que estão presentes na lógica. Cada palavra na linguagem formal é dita uma \emph{fórmula bem-formada}, ou, simplesmente, uma \emph{fórmula}.

Para cada lógica, é definida também uma \emph{semântica}, um instrumento para atribuir \emph{significado} às fórmulas. Isto é feito através da definição de diferentes \emph{interpretações}. Sob uma mesma interpretação, cada fórmula deve possuir um único significado. Em lógicas clássicas, como a \emph{lógica proposicional} e a \emph{lógica de primeira ordem}, o significado de uma fórmula sob uma interpretação deve ser somente um dentre dois valores possíveis: \emph{verdadeiro} ou \emph{falso}.

\emph{Satisfatibilidade}, o problema de determinar se existe uma interpretação sob a qual uma fórmula é verdadeira, é de grande interesse prático. Tal problema aparece, por exemplo, em vários desafios da microeletrônica, como síntese \cite{bloem2014sat}, otimização \cite{nieuwenhuis2006sat} e verificação de \textit{hardware} \cite{gupta2006sat}. Aparece também em problemas de raciocínio automático \cite{harrison2009handbook} e em muitos outros problemas relevantes \cite{horvitz1992automated}.

Satisfatibilidade é também de grande interesse teórico. Em 1971, Cook definiu a classe dos problemas \emph{NP-completos}, sendo satisfatibilidade proposicional o primeiro problema a ser descoberto como representativo desta classe. A partir destes resultados, Cook formalizou o enunciado do maior problema ainda não resolvido da Ciência da Computação:\break P \emph{versus} NP \cite{cook1971complexity}.

\emph{Validade}, o problema de determinar se uma dada fórmula é verdadeira sob \emph{qualquer} interpretação, é fortemente ligado ao problema da satisfatibilidade \cite{kleene68book}. Por esta forte relação, que detalhamos no Capítulo \ref{cap_referencial}, o problema da validade é também extensamente investigado.

Grande avanço já foi feito em direção a algoritmos de busca rápidos para satisfatibilidade e validade \cite{davis1960computing,davis1962machine,biere2009conflict}, apesar de ser conjecturado que qualquer algoritmo terá custo de tempo exponencial determinístico no pior caso \cite{cook1971complexity}.

Uma característica comum a diversos dos algoritmos para satisfatibilidade e validade é a redução do problema a fórmulas em uma determinada \emph{forma normal}. Uma forma normal é uma imposição de restrições sobre a forma de uma fórmula, ou seja, é um subconjunto das fórmulas de uma lógica. Formas normais criam vantagens ao lidar com problemas da lógica, pois fórmulas em formas mais restritas possuem mais propriedades em comum que podem ser exploradas, além do fato de que menos situações precisam ser consideradas pelos algoritmos.

Em algoritmos que utilizam formas normais, etapas de pré-processamento são necessárias, pois é preciso transformar uma fórmula qualquer para outra que esteja na respectiva forma normal. É importante ainda que o pré-processamento tenha custo de tempo polinomial determinístico. Somente assim a técnica implementada será de fato vantajosa, em vista da conjectura sobre o custo de tempo de qualquer algoritmo de busca para satisfatibilidade e validade.

Considerando a possibilidade de melhorar a eficiência total de pré-processamento e busca, conjectura-se que fórmulas menores produzem respostas mais rápido \cite{nonnengart2001computing}. O objetivo deste trabalho é testar esta hipótese através de experimentos. Em particular, investigamos algoritmos baseados na \emph{forma normal clausal}, definida formalmente no Capítulo \ref{cap_referencial}. Para obter fórmulas menores, implementamos algoritmos que reduzem o \emph{número de cláusulas} através de \emph{renomeamento}, conceitos também definidos no Capítulo \ref{cap_referencial}. Boy de la Tour \cite{de1992optimality} e Jackson et al. \cite{jackson2004clause} propõem algoritmos para este fim. No Capítulo \ref{cap_algoritmo}, propomos o nosso algoritmo para este fim, que permite ainda encontrar boas transformações restringindo o tamanho máximo do renomeamento. Comparamos o algoritmo proposto com o de Boy de la Tour no Capítulo \ref{cap_resultados} e, por fim, propomos trabalhos futuros no Capítulo \ref{cap_conclusao}.
