\indent

Lógicas têm sido utilizadas em Computação para representar e raciocinar sobre problemas. A representação se dá através de uma linguagem formal, que define a \emph{sintaxe} de uma lógica em particular, ou seja, a \emph{forma} dos enunciados que estão presentes na lógica. Cada palavra na linguagem formal é dita uma \emph{fórmula bem formada}, ou, simplesmente, uma \emph{fórmula}.

Para cada lógica é definida também uma \emph{semântica}, um instrumento para atribuir \emph{significado} às fórmulas. Isto é feito através da definição de diferentes \emph{interpretações}. Sob uma mesma interpretação, cada fórmula deve possuir um único significado. Em lógicas clássicas, como \emph{lógica proposicional} e \emph{lógica de primeira ordem}, o significado de uma fórmula sob uma interpretação deve ser somente um entre dois valores possíveis: \emph{verdadeiro} ou \emph{falso}.

\emph{Satisfatibilidade}, o problema de determinar se existe uma interpretação sob a qual uma fórmula é verdadeira, é de grande interesse prático. Tal problema aparece, por exemplo, em vários problemas da microeletrônica, como síntese \cite{bloem2014sat}, otimização \cite{gupta2006sat} e verificação \cite{nieuwenhuis2006sat} de \textit{hardware}. Aparece também em problemas de raciocínio automático \cite{harrison2009handbook} e em muitos outros problemas relevantes \cite{horvitz1992automated}.

Satisfatibilidade é também de grande interesse teórico. Em 1971, Cook definiu a classe dos problemas \emph{NP-completos}, sendo satisfatibilidade proposicional o primeiro problema a ser descoberto como representativo desta classe. A partir destes resultados, Cook\break formalizou o enunciado do maior problema ainda não resolvido da Ciência da Computação:\break P versus NP \cite{cook1971complexity}.

Equivalente ao problema da satisfatibilidade é o problema da \emph{validade}: determinar se uma dada fórmula é verdadeira sob \emph{qualquer} interpretação. Por esta forte relação com satisfatibilidade, que detalhamos no próximo capítulo, o problema da validade é também extensamente investigado.

Grande avanço já foi feito em direção a algoritmos de busca rápidos para satisfatibilidade e validade \cite{davis1960computing,davis1962machine,biere2009conflict}, apesar de ser conjecturado que qualquer um terá custo de tempo exponencial determinístico no pior caso.

Uma característica comum a diversos dos algoritmos para satisfatibilidade e validade é a redução do problema a fórmulas em uma determinada \emph{forma normal}. Uma forma normal é uma imposição de restrições sobre a forma de uma fórmula, ou seja, é um subconjunto das fórmulas de uma lógica. Formas normais criam vantagens ao lidar com problemas da lógica, pois fórmulas em formas mais restritas possuem mais propriedades em comum que podem ser exploradas, além do fato de que menos situações precisam ser consideradas pelos algoritmos.

Em algoritmos que utilizam formas normais, etapas de pré-processamento são necessárias, pois é necessário transformar uma fórmula qualquer para outra que esteja na respectiva forma normal. É importante ainda que um pré-processamento tenha custo de tempo polinomial determinístico. Somente assim a técnica implementada será de fato vantajosa, em vista da conjectura sobre o custo de tempo de qualquer algoritmo de busca para satisfatibilidade e validade.

Considerando a possibilidade de melhorar a eficiência total de pré-processamento e busca, conjecturamos que fórmulas menores produzem a saída mais rápido. O objetivo deste trabalho é testar esta hipótese através de experimentos. Em particular, investigamos algoritmos baseados na \emph{forma normal clausal}, definida formalmente no próximo capítulo. Para obter fórmulas menores, implementamos algoritmos que minimizam o \emph{número de cláusulas} através de \emph{renomeamento}, conceitos também definidos no próximo capítulo. Propomos ainda um algoritmo de programação dinâmica para este fim, que de fato encontra transformações com o número mínimo de cláusulas. O algoritmo proposto permite ainda encontrar transformações ótimas incluindo a restrição de limitar o tamanho do renomeamento.
